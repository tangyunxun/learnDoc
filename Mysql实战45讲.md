#### 1.基础架构：一条SQL查询语句是如何执行的？

<img src="C:\Users\Axun\Desktop\mysql基本架构图.png" style="zoom: 25%;" />

连接器：建立连接

分析器：词法分析、语法分析。语法不对就会收到“You have an error in your SQL syntax”。

优化器：决定使用哪个索引，多表关联时的关联顺序等等。

执行器：先判断对表有没有操作权限，有的话则继续调用引擎的接口

查询缓存：多数情况下不建议使用。mysql8.0已经删掉了这个模块

判断表结构是否包含某字段，发生在**分析器**。



#### 2.日志系统：一条SQL更新语句是如何执行的？

redo log与binlog不同之处：

+ redo log是InnodDB特有，binlog属于server层；
+ redo log是物理日志，binlog 是逻辑日志；
+ redo log是循环写的，binlog追加写。

update语句执行流程：

<img src="C:\Users\Axun\Desktop\mysql更新流程.png" style="zoom:25%;" />

redo log与binlog的**二阶段提交**。

建议：innodb_flush_log_at_trx_commit设置成1，表示每次事务的redo log都持久化到磁盘；

sync_binlog也设置成1，表示每次事务的binlog都持久化到磁盘。



#### 3.事务隔离：为什么你改了我还看不见？

隔离级别：

+ 读未提交（脏读），当前读
+ 读已提交（不可重复读），使用每个语句执行前的read view
+ 可重复读（幻读），使用每个事务最初的read view
+ 串行化，加锁避免并行访问

可重复读的场景：对账。

每次更新都会同时记录一条undo log，当没有事务需要用到该undo log时，系统才会将之删除。

长事务的影响：undo log不能及时删除；锁长时间得不到释放，对于高并发的更新，连接容易被打满；主从同步延迟大。



#### 4-5.索引基础

索引常见模型：

+ 哈希表。适用于等值查询。
+ 数组。适用于等值查询以及范围查询，但是对增删数据不友好，**适用于静态存储**。
+ B+树。树高与磁盘访问次数成正比。尽量缩小key的长度，使得一个数据页存储更多的key，以缩小树高。主键尽量使用递增的id。

使用B+树作为索引的原因：**B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。**

回表：回到主键索引树搜索的过程，称为回表。

覆盖索引：索引中包含全部待查询字段，不需要回表，此时称为覆盖索引。（字符串的前缀索引会使得覆盖索引失效）

最左前缀。建立联合索引的时候，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往是需要优先考虑的。其次考虑占用空间。

索引下推：**在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。**

倒排索引：搜索引擎中的概念。把文章分词后的单词作为key，value存储与之对应的文档id以及其他信息。



#### 6.全局锁和表锁 ：给表加个字段怎么有这么多阻碍？

根据加锁的范围：全局锁、表级锁、行锁。

+ 加全局锁的典型场景：全库逻辑备份。InnoDB使用mysqldump;对于不支持事务的引擎，推荐FTWRL：整个库处于只读状态。

+ 表级锁：表锁、元数据锁（MDL）。

  当对数据库做DML时，加MDL读锁，做DDL时，加MDL写锁。

  事务中的MDL，在语句开始执行时申请，在事务提交后释放。

  热点表，加个字段真的挺难。kill长事务；在alter table语句中加入等待时间，能够在指定时间内拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。



#### 7.行锁功过：怎么减少行锁对性能的影响？

两阶段锁协议：InnoDB中，行锁在需要的时候加上，事务提交后才释放。

因此，我们要把最可能造成锁冲突、最可能影响并发的的锁尽量往后放。

处理死锁策略，往往采用死锁检测：

1. 直接进入等待，直到超时。通过参数 innodb_lock_wait_timeout 根据实际业务场景来设置超时时间，InnoDB引擎默认值是50s。
2. 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务。innodb_deadlock_detect 设置为 on，表示开启这个逻辑（默认是开启状态）

死锁检测：每个新来的被堵住的线程，都要判断会不会由于自己的加入导致死锁，这是一个O(n)的操作。

热点行的更新，死锁检测效率较低，应对方案：

1. 如果业务可以确保无死锁，那么可以关掉死锁检测。（不推荐）
2. 控制并发度，限流。对应相同行的更新，在进入引擎之前排队。
3. 将热更新的行数据拆分成逻辑上的多行来减少锁冲突，但是业务复杂度可能会大大提高。

**innodb行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。**



#### 8.事务到底是隔离的还是不隔离的？

InnoDB为每一个事务构造一个数组，用来保存在事务启动的瞬间，当前正在活跃（启动了但还没提交）的所有事务ID。

事务ID的最小值记为低水位，**当前系统里面已经创建过的事务ID的最大值加1记为高水位**。这个视图数组和高水位就构成了当前事务的一致性读视图。InnoDB利用了“所有数据都有多个版本”的特性，实现了“**秒级创建快照**”的能力。

<img src="C:\Users\Axun\Desktop\mysql数据版本可见性规则.png" style="zoom: 33%;" />

1. 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；

2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；

3. 如果落在黄色部分，那就包括两种情况

   a.  若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；

   b.  若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。

更新语句都是先读后写的，这个读只能读当前值，称为“**当前读**”（current read）。



#### 9.普通索引和唯一索引，应该怎么选择？

两方面考虑：

+ 对于查询语句，唯一索引效率稍高，但是可以忽略不计。

+ 对于更新操作，唯一索引不能使用change buffer。

change buffer适用于写多读少，不适用于写了立即读的场景，那样反而会成为累赘。

**redo log主要减少随机写磁盘，change buffer主要减少随机读磁盘。**

仔细体会更新的细节，忘记就回去看原文。

系统突然宕机，change buffer数据丢失，会使得更新丢失吗？

不会，因为redo log记录了change buffer的值，崩溃恢复的时候能找回来。



#### 10.MySQL为什么有时候会选错索引？

判断依据：扫描行数、是否使用临时表、是否需要排序

+ force index强行选择一个索引
+ 修改语句，引导mysql使用我们期望的索引
+ 有些场景下，新建一个更合适的索引或删掉误用的索引

感觉本文不是太重要。

全文不太重要

#### 11. 怎么给字符串字段加索引？

字符串字段创建索引的场景:

+ 直接创建完整索引，这样可能比较占用空间；
+ 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；
+ 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；
+ 创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。

在实际应用中，你要根据业务字段的特点选择使用哪种方式。



#### 12.为什么我的MySQL会“抖”一下？

刷脏页（flush）会导致查询或更新慢一些。刷脏页的四种场景：

+ redo log满了。这时候会停止所有更新操作
+ 内存没有空闲page cache，需要淘汰一些（LRU），如果是脏页就要flush
+ 空闲的时候flush脏页
+ mysql正常关闭的时候flush

刷脏页虽然是常态，但是出现以下两种情况，都是会明显影响性能的：

+ 一个查询要淘汰的脏页太多，导致查询时间明显增长
+ redo log写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说是不能接受的。

innodb_max_dirty_pages_pct 指定脏页比例上限

刷脏页的连坐机制 innodb_flush_neighbors。机械硬盘有用，减少随机写。ssd建议取消。

#### 13.为什么表数据删掉一半，表文件大小不变？

造成数据空洞的情况：

+ delete命令只是把记录的位置或者数据页标记为“可复用”，但磁盘文件的大小是不会变的。

+ 随机插入数据，可能会造成页分裂，从而造成空洞；

+ 更新索引的值，可以理解为删除旧值，插入新值，也会造成空洞

经过大量增删改查的表都是存在空洞的。重建表可以把这些空洞去掉。

重建表的细节暂不关心。



#### 14.count(*)这么慢，我该怎么办？

count(*)的实现方式：

+ 在MyISAM中，存储了全表的总行数，可以直接返回，效率很高。
+ InnoDB中，没有存储总行数（因为mvcc的存在）， 需要把数据一行行地从引擎中读出来，效率不高。

使用缓存（redis）存储总行数，缺陷是即使缓存不出问题，那么写缓存和写数据库之间的时间差，也难保逻辑正确。

把计数存在mysql的计数表里，和业务增删数据在一个事务中。

按照效率排序的话，count(字段)<count(主键 id)<count(1)≈count(\*)，所以尽量使用 count(*)。



#### 16.“order by”是怎么工作的？

max_length_for_sort_data，用于控制mysql中参与排序的行数据的长度的参数。如果单行超过这个值，就是用rowid排序。

全字段排序：所有查询的字段都放入sort buffer，排序完直接返回，不需要回表。

rowid排序：参与排序字段和主键id放入sort buffer，排序完拿着id回表查出待查询数据。

因为原来的数据是无序的，才需要排序。若是有序的，order by可以不排序，争取用到索引。



#### 17.如何正确地显示随机消息？

本节内容比较干，建议多看原文。

rowid的含义：

+ 对于有主键的 InnoDB 表来说，这个 rowid 就是主键 ID；
+ 对于没有主键的 InnoDB 表来说，这个 rowid 就是由系统生成的；
+ MEMORY 引擎不是索引组织表。在这个例子里面，你可以认为它就是一个数组。因此，这个 rowid 其实就是数组的下标。







#### 18.为什么这些SQL语句逻辑相同，性能却差异巨大？

B+树提供的快速定位能力，源自于同一层兄弟节点的有序性。

**对索引字段的函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。**但并不是放弃使用这个索引。

触发函数操作的场景：

+ 显示使用函数，x+1=10000也不行，应该写成x = 10000-1；
+ 隐式类型转换；
+ 隐式字符编码转换。



#### 19.为什么我只查一行的语句，也执行这么慢？

+ 查询长时间不返回
  - 等MDL锁（一个线程正在表t请求或者持有MDL写锁，把select语句堵住了）
  - 等flush（flush tables t with read lock; flush tables with read lock;正常这两个执行都很快，除非被别的线程堵住了）
  - 等行锁（select * from t where id=1 lock in share mode;如果一个事务已经在改行持有写锁，就会堵住该select）
+ 查询慢
  - 没用到索引，扫描行数多
  - 用到主键索引，扫描行数是1。长事务大量的执行undo log回退版本，也会很慢。





#### 20. 幻读是什么，幻读有什么问题？

幻读：是指一个事务中前后两次查询同一范围，后一次查询看到了前一次查询没看到的行。

幻读的说明：

+ 在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读仅在“当前读”下才会出现；
+ 幻读仅指“新插入的行”。

为了解决幻读而引入间隙锁。**跟间隙锁存在冲突关系的，是“往这个间隙中插入一行记录”这个操作**。

间隙锁和行锁合称next-key lock，每个next-key lock都是前开后闭区间。

间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。

间隙锁只有在可重复读隔离级别下才生效。



#### 21.为什么我只改一行的语句，锁这么多？

列举了8种加锁的例子，值得好好体会。多看看







